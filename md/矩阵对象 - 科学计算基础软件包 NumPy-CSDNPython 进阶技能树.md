> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [edu.csdn.net](https://edu.csdn.net/skill/python02/python-3-201?category=882&typeId=17511)

> CSDN 矩阵对象社区, 矩阵对象论坛, 为中国软件开发者打造学习和成长的家园

1. 矩阵对象
-------

在数学上，矩阵（Matrix）是一个按照矩形阵列排列的复数或实数集合，但在 NumPy 中，矩阵 np.matrix 是数组 np.ndarray 的派生类。这意味着矩阵本质上是一个数组，拥有数组的所有属性和方法；同时，矩阵又有一些不同于数组的特性和方法。

*   首先，矩阵是二维的，不能像数组一样幻化成任意维度，即使展开或切片，返回也是二维的；
*   其次，矩阵和矩阵、矩阵和数组都可以做加减乘除运算，运算结果总是返回矩阵；
*   最后，矩阵的乘法不同于数组乘法。

2. 创建矩阵
-------

np.mat() 函数用于创建矩阵，它可以接受列表、数组甚至是字符串等形式的参数，还可以使用 dtype 参数指定数据类型，其代码如下。

```
>>> import numpy as np
>>> np.mat([[1,2,3],[4,5,6]], dtype=np.int32) 
matrix([[1, 2, 3],
        [4, 5, 6]])
>>> np.mat(np.arange(6).reshape((2,3))) 
matrix([[0, 1, 2],
        [3, 4, 5]])
>>> np.mat('1 4 7; 2 5 8; 3 6 9') 
matrix([[1, 4, 7],
        [2, 5, 8],
        [3, 6, 9]])


```

此外，和生成特殊值数组类似，numpy.matlib 子模块（）也提供了多个函数用于生成特殊值矩阵和随机数矩阵，其代码如下。

```
>>> import numpy.matlib as mat 
>>> print(mat.zeros((2,3))) 
[[0. 0. 0.]
 [0. 0. 0.]]
>>> print(mat.ones((2,3))) 
[[1. 1. 1.]
 [1. 1. 1.]]
>>> print(mat.eye(3)) 
[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
>>> print(mat.empty((2,3))) 
[[1. 1. 1.]
 [1. 1. 1.]]
>>> print(mat.rand((2,3))) 
[[0.505 0.494 0.96 ]
 [0.681 0.002 0.281]]
>>> print(mat.randn((2,3))) 
[[ 1.984  2.452  0.567]
 [ 0.646 -0.909  0.774]]


```

3. 矩阵属性
-------

矩阵有几个特有的属性，如转置矩阵、逆矩阵、共轭矩阵、共轭转置矩阵等。熟悉这些属性对矩阵计算会有很大的帮助。

```
>>> m = np.mat(np.arange(6).reshape((2,3)))
>>> print(m)
[[0 1 2]
 [3 4 5]]
>>> print(m.T) 
[[0 3]
 [1 4]
 [2 5]]
>>> print(m.H) 
[[0 3]
 [1 4]
 [2 5]]
>>> print(m.I) 
[[-0.778  0.278]
 [-0.111  0.111]
 [ 0.556 -0.056]]
>>> print(m.A) 
[[0 1 2]
 [3 4 5]]


```

4. 矩阵乘法
-------

矩阵运算和数组运算大致相同，只有乘法运算有较大差别。在讲广播和矢量化时，我们已经知道，两个数组相乘就是对应元素相乘，条件是两个数组的结构相同。事实上，即使两个数组的结构不同，只要满足特定条件，也能做乘法运算。

除了对应元素相乘，数组还可以使用 np.dot() 函数相乘，其代码如下。

对于数组而言，使用星号相乘和使用 np.dot() 函数相乘是完全不同的两种乘法；对于矩阵来说，不管是使用星号相乘还是使用 np.dot() 函数相乘，结果都是 np.dot( ) 函数相乘的结果，因为矩阵没有对应元素相乘这个概念。np.dot() 函数实现的乘法就是矩阵乘法。那么矩阵乘法究竟是怎么运算的呢？下图是矩阵相乘的具体算法示意图。

![](https://img-blog.csdnimg.cn/20191221180251751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dWZpdmUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70#pic_center)不是所有的矩阵都能相乘。我们来看，矩阵 A 乘以矩阵 B，二者可以相乘的条件是：A 的列数必须等于 B 的行数。比如，a 是 4 行 2 列，b 是 2 行 3 列，axb，4223，没问题，但是反过来，bxa，2342，就无法运算了。可见，矩阵乘法，不满足交换律。再来看看乘法规则。概括说，就是 A 的各行逐一去乘 B 的各列。比如，A 的第 1 行和 b 的第 2 列，元素个数一定相等，对应元素相乘后求和，作为结果矩阵第 1 行第 2 列的值。再比如，a 的第 3 行和 b 的第 3 列，对应元素相乘后求和，作为结果矩阵第 3 行第 3 列的值。以此类推，我们就得到了矩阵 A 乘以矩阵 B 的结果矩阵。

那么，这个眼花缭乱的矩阵乘法，有什么实用价值吗？答案是：有，不但有，而且有非常大的使用价值。对于程序员来说，矩阵乘法最常见的应用是图像的旋转、位移、透视等操作。下面，我们来推导一个平面直角坐标系的旋转矩阵。  
![](https://img-blog.csdnimg.cn/20191221180633577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dWZpdmUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70#pic_center)  
下面，我们应用这个推导结果，定义一个函数，返回平面上的点围绕原点旋转给定角度后的坐标：

```
>>> def rotate(p,d):
	a = np.radians(d)
	m = np.array([[np.cos(a), np.sin(a)],[-np.sin(a), np.cos(a)]])
	return np.dot(np.array(p), m)

>>> rotate((5.7,2.8), 35) 
array([3.06315263, 5.56301141])
>>> rotate((5.7,2.8), 90) 
array([-2.8,  5.7])
>>> rotate((5.7,2.8), 180) 
array([-5.7, -2.8])
>>> rotate((5.7,2.8), 360) 
array([5.7, 2.8])


```

关于矩阵及其乘法，我们就讨论这么多。难度应该不大，但对于有数学恐惧症的程序员来说，会感到紧张。没关系，只要记住旋转矩阵的使用方法，即使不懂数学，也照样可以成为优秀的 Python 程序员。